package edu.iastate.cs472.proj1;

import java.io.FileNotFoundException;

/**
 *  
 * @author HoiPhung
 *
 */

public class EightPuzzle {


	/**
	 * This static method solves an 8-puzzle with a given initial state using three heuristics. The
	 * first two, allowing single moves only, compare the board configuration with the goal configuration
	 * by the number of mismatched tiles, and by the Manhattan distance, respectively.  The third
	 * heuristic, designed by yourself, allows double moves and must be also admissible.  The goal
	 * configuration set for all puzzles is
	 * <p>
	 * 1 2 3
	 * 8   4
	 * 7 6 5
	 *
	 * @param s0
	 * @return a string specified in the javadoc below
	 */
	public static String solve8Puzzle(State s0) {
		// TODO 

		// 1) Return a message that starts with "No solution exists for the following initial 
		//    state:" and follows with a blank line and then what would be the output from a 
		//    call s0.toString(). See the end of Section 6 in the project description for an 
		//    example. 

		if (!s0.solvable()) {
			System.out.println("No solution exists for the following initial state:\n" + s0.toString());
			return "No solution exists for the following initial state:\n" + s0.toString();
		}


		// 2) Otherwise, solve the puzzle with the three heuristics.  The two solutions generated by
		//    the first two heuristics may be different but must have the same length for optimality. 

		Heuristic h[] = {Heuristic.TileMismatch, Heuristic.ManhattanDist, Heuristic.DoubleMoveHeuristic};
		String[] moves = new String[3];

		for (int i = 0; i < 3; i++) {
			moves[i] = AStar(s0, h[i]);
			System.out.print(h[i].name()+ " ");
			System.out.println(moves[i]);
		}

		// 3) Combine the three solution strings into one that would print out in the 
		//    output format specified in Section 6 of the project description.

		return null;
	}


	/**
	 * This method implements the A* algorithm to solve the 8-puzzle with an input initial state s0.
	 * The algorithm implementation is described in Section 3 of the project description.
	 * <p>
	 * Precondition: the puzzle is solvable with the initial state s0.
	 *
	 * @param s0 initial state
	 * @param h  heuristic
	 * @return solution string
	 */
	public static String AStar(State s0, Heuristic h) {

		// TODO 

		// Initialize the two lists used by the algorithm. 
		OrderedStateList OPEN = new OrderedStateList(h, true);
		OrderedStateList CLOSE = new OrderedStateList(h, false);

		if (s0.solvable()) {
			OPEN.addState(s0);
		}

		CLOSE.addState(s0);
		OPEN.removeState(s0);
		while (!s0.isGoalState()) {
			for (Move x : Move.values()) {
				if (h == Heuristic.DoubleMoveHeuristic) {     // when double move is allowed
					State successor = s0.successorState(x);
					if (successor != null) {
						if (successor.isGoalState()) {
							return solutionPath(successor);
						}

						if (OPEN.findState(successor) != null && OPEN.findState(successor).equals(successor)) {
							State old = OPEN.findState(successor);
							if (successor.cost() < old.cost()) {
								old.numMoves = successor.numMoves - 1;
								old.predecessor.cost();
								old.predecessor = successor;
							}

						} else if (CLOSE.findState(successor) != null && CLOSE.findState(successor).equals(successor)) {
							State old = CLOSE.findState(successor);
							if (successor.cost() < old.cost()) {
								CLOSE.removeState(old);
								OPEN.addState(successor);
							}

						} else {
							OPEN.addState(successor);
						}
					}

				} else {

					if (x != Move.DBL_DOWN && x != Move.DBL_LEFT && x != Move.DBL_UP && x != Move.DBL_RIGHT) {    // when double move is not allowed
						State successor = s0.successorState(x);
						if (successor != null) {
							if (successor.isGoalState()) {
								return solutionPath(successor);
							}

							if (OPEN.findState(successor) != null && OPEN.findState(successor).equals(successor)) {
								State old = OPEN.findState(successor);
								if (successor.cost() < old.cost()) {
									old.numMoves = successor.numMoves - 1;
									old.predecessor.cost();
									old.predecessor = successor;
								}

							} else if (CLOSE.findState(successor) != null && CLOSE.findState(successor).equals(successor)) {
								State old = CLOSE.findState(successor);
								if (successor.cost() < old.cost()) {
									CLOSE.removeState(old);
									OPEN.addState(successor);
								}

							} else {
								OPEN.addState(successor);
							}
						}
					}
				}
			}

			s0 = OPEN.remove();

		}



	// Implement the algorithm described in Section 3 to solve the puzzle.
	// Once a goal state s is reached, call solutionPath(s) and return the solution string.


		return solutionPath(s0);
						
	}
	
	
	
	/**
	 * From a goal state, follow the predecessor link to trace all the way back to the initial state. 
	 * Meanwhile, generate a string to represent board configurations in the reverse order, with 
	 * the initial configuration appearing first. Between every two consecutive configurations 
	 * is the move that causes their transition. A blank line separates a move and a configuration.  
	 * In the string, the sequence is preceded by the total number of moves and a blank line. 
	 * 
	 * See Section 6 in the projection description for an example. 
	 * 
	 * Call the toString() method of the State class. 
	 * 
	 * @param goal
	 * @return
	 */
	private static String solutionPath(State goal)
	{
         int move = goal.numMoves;
		String result= "";
		// TODO
		while(goal != null){
			result= goal.toString() +result;
			if(goal.move != null) {
				result = "\n" + result;
				result = "\n"+goal.move.name() + result;

			}

			goal = goal.predecessor;

		}
		result = move+ " moves in total\n" + result;


		
		return result;
	}
	
	
	
}
